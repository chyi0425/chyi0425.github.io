---
title: 原码，反码，补码
date: 2018-07-22 21:19:49
tags: [Java,bit] #文章标签，多于一项时用这种格式
toc: true
---

## 机器数和真值

### 机器数
一个数在计算机中的二进制表示形式，叫做这个数的机器数。机器数是带符号的，在计算机用一个数的最高位存放符号，正数为0，负数为1。
比如，十进制中的数 +3，计算机字长为8位，转换成二进制就是 0000 0011。如果是-3，就是 1000 0011。
那么，这里的 0000 0011 和 1000 0011就是机器数。

### 真值

> 因为第一位是符号位，所以机器数的形式值就不等于真正的数值。例如上面的有符号数 1000 0011，其最高位1代表负，其真正的数值是-3 而不是形式值131（1000 0011转换成10进制等于131）。所以为区别起见，将带符号位的机器数对应的真正数值称为机器数的真值。

例如： 0000 0011的真值= +000 0001 = +1，1000 0011的真值是= -000 0001 = -1

## 原码，反码，补码的基础概念和计算方法
对于一个数，计算机要使用一定的编码方式进行存储。原码，反码，补码是机器存储一个具体数字的编码方式。

### 原码
原码就是符号位加上真值的绝对值，即用第一位表示符号，其余位表示值。比如如果是8位二进制：

> [+1]原 = 0000 0001
> [-1]原 = 1000 0001

第一位是符号位。因为第一位是符号位。所以8位二进制数的取值范围就是：

> [1111 1111, 0111 1111]

即

> [-127, 127]

原码是人脑最容易理解和计算的表示方式。

### 反码
反码的表示方法是：
正数的反码是其本身
负数的反码是在其原码的基础上，符号位不变，其余各个取反。

> [+1] = [0000 0001]原 = [0000 0001]反
> [-1] = [1000 0001]原 = [1111 1110]反

可见如果一个反码表示的是负数，人脑无法直观的看出来它的数值。通常要将其转换成原码再计算。

### 补码
补码的表示方法是：
正数的补码就是其本身
负数的补码是在其原码的基础上，符号位不变，其余各位取反，最后+1。（即在反码的基础上+1）

> [+1] = [0000 0001]原 = [0000 0001]反 = [0000 0001]补
> [-1] = [1000 0001]原 = [1111 1110]反 = [1111 1111]补
对于负数，补码表示方式也是人脑无法直观看出其数值的。通常也需要转换成原码在计算其数值。

## 为何要使用原码，反码和补码
现在我们知道了计算机可以有三种编码方式表示一个数。对于正数因为三种编码方式的结果都相同：

> [+1] = [0000 0001]原 = [0000 0001]反 = [0000 0001]补

但是对于负数：

> [-1] = [1000 0001]原 = [1111 1110]反 = [1111 1111]补

可见原码，反码，补码是完全不同的。既然原码才是被人脑直接识别并用于计算表示方式，为何还会有反码和补码呢？

首先，因为人脑可以知道第一位是符号位，在计算的时候我们会根据符号位，选择对其真值区域的加减。但是对于计算机，加减乘除已经是最基础的运算，要设计的尽量简单。计算机辨别“符号位”显然会让计算机的基础电路设计变得十分复杂！于是人们想出了将符号位也参与运算的方法。我们知道，根据运算法则减去一个正数等于加上一个负数，所以机器可以只有加法而没有减法，这样计算机运算的设计就更加简单了。

于是人们开始探索将符号位参与运算，并且只保留加法的方法。首先来看原码：
计算十进制的表达式：1-1=0

> 1 - 1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原 = [1000 0010]原 = -2

如果用原码表示，让符号位也参与计算，显然对于减法来说，结果是不正确的。这也就是为何计算机内部不使用原码表示一个数的原因。

为了解决原码做减法的问题，出现了反码：

计算十进制的表达式 1 - 1 = 0

> 1 - 1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原=[0000 0001]反 + [1111 1110]反 = [1111 1111]反 = [1000 0000]反 = -0

发现用反码计算减法，结果真值的部分是正确的。而唯一的问题就出现在“0”这个特殊值上。虽然人们理解+0 -0是一样的，但是0带符号是没有任何意义的。而且会有[0000 0000]原 和[1000 0000]原 两个编码表示0.

于是补码的出现，解决了0的符号以及两个编码的问题：

> 1 - 1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原 = [0000 0001]补 + [1111 1111]补 = [0000 0000]补 = [0000 0000]原

这样0用[0000 0000]表示，而以前出现问题的-0就不存在了。而且可以用[1000 0000]表示-128:

> (-1) + (-127) = [10000 0001]原 + [1111 1111]原 = [1111 1111]补 + [1000 0001]补 = [1000 0000]补

## 原码，反码，补码 再深入

计算机巧妙地把符号位参与运算，并且将减法变成了加法，背后蕴含了怎样的数学原理呢?

将钟表想象成是一个1位的12进制数. 如果当前时间是6点, 我希望将时间设置成4点, 需要怎么做呢?我们可以:

> 1. 往回拨2个小时: 6 - 2 = 4
> 2. 往前拨10个小时: (6 + 10) mod 12 = 4
> 3. 往前拨10+12=22个小时: (6+22) mod 12 =4

2,3方法中的mod是指取模操作, 16 mod 12 =4 即用16除以12后的余数是4.

所以钟表往回拨(减法)的结果可以用往前拨(加法)替代!

现在的焦点就落在了如何用一个正数, 来替代一个负数. 上面的例子我们能感觉出来一些端倪, 发现一些规律. 但是数学是严谨的. 不能靠感觉.

首先介绍一个数学中相关的概念: 同余

### 同余的概念

两个整数a，b，若它们除以整数m所得的余数相等，则称a，b对于模m同余

记作 a ≡ b (mod m)

读作 a 与 b 关于模 m 同余。

举例说明:

> 4 mod 12 = 4
> 16 mod 12 = 4
> 28 mod 12 = 4

所以4, 16, 28关于模 12 同余.

