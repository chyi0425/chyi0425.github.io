---
title: network-overview
date: 2019-01-28 11:16:39
tags: [udp,tcp,network]
toc: true
---

## UDP协议

### UDP TCP区别

1. TCP提供可靠交付。通过TCP链接传输的数据，无差错，不丢失，不重复，并且按序到达。而UDP继承了IP包的特性，不保证不丢失，不保证按顺序到达。
2. TCP是面向字节流的。发送的时候发的是一个流，没头没尾。而UDP继承了IP包的特性，基于数据报的，一个一个地发，一个一个地收。
3. TCP是可以有拥塞控制的。UDP就不会，应用让我发，我就发，管他洪水滔天。

因此：**TCP其实是一个有状态服务**,而**UDP是无状态服务**

### UDP包头是什么样的

![示意图](/img/network-1.jpg)

### UDP的三大特点

1. 沟通简单，不需要一肚子花花肠子（大量的数据结构、处理逻辑、包头字段）提是它相信网络世界是美好的，秉承性善论，相信网络通路默认就是很容易送达的，不容易被丢弃的。
2. 轻信他人它不会建立连接，虽然有端口号，但是监听在这个地方，谁都可以传给他数据，他也可以传给任何人数据，甚至可以同时传给多个人数据。
3. 愣头青，做事不懂权变不知道什么时候该坚持，什么时候该退让。它不会根据网络的情况进行发包的拥塞控制，无论网络丢包丢成啥样了，它该怎么发还怎么发。

### UDP的三大使用场景

1. 需要资源少，在网络情况比较好的内网，或者对于丢包不敏感的应用。
2. 不需要一对一沟通，建立连接，而是可以广播的应用。
3. 需要处理速度快，时延低，可以容忍少数丢包，但是要求即便网络拥塞，也毫不退缩，一往无前的时候。

## TCP协议

### TCP的状态

* SYN表示建立连接
* FIN表示关闭连接
* ACK表示响应
* PSH表示有DATA数据传输
* RST表示连接重置 

### TCP包头格式

![示意图](/img/network-2.jpg)

通过对TCP头的解析，我们知道要掌握TCP协议，重点应该关注以下几个问题：

* 顺序问题，稳重不乱；
* 丢包问题，承诺靠谱
* 连接维护，有始有终；
* 流量控制，把握分寸；
* 拥塞控制，知进知退。

### TCP的三次握手

我们也常称为“请求->应答->应答之应答”的三个回合。

在连接建立的过程中，双方的状态变化时序图就像这样。

![示意图](/img/network-3.jpg)

一开始，客户端和服务的都处于CLOSE状态。先是服务端主动监听某个端口，处于LISTEN状态。然后客户端主动发起连接SYN，之后处于SYN-SENT状态。服务端收到发起的连接，返回SYN，并且ACK客户端的SYN，之后处于SYN-RCVD状态。客户端收到服务端发送的SYN和ACK之后，发送ACK的ACK，之后处于ESTABLISHED状态，因为它一发一收成功了。服务端收到ACK的ACK之后，处于ESTABLISHED状态，因为它也一发一收了。

### TCP四次挥手

说完连接，接下来说一说“拜拜”，好说好散。这常被称为四次挥手。

我们来看断开连接的时候的状态时序图

![示意图](/img/network-4.jpg)

当A说“不玩了”，就进入FIN_WAIT_1的状态，B收到“A不玩了”的消息后，发送知道了，就进入CLOSE_WAIT的状态。

A收到“B说知道了”，就进入FIN_WAIT_2的状态，如果这个时候B直接跑路，则A将永远在这个状态。TCP协议里面并没有对这个状态的处理，但是LINUX有，可以调整fin_fin_timeout这个参数，设置一个超时时间。

如果B没有跑路，发送了“B也不玩了”的请求到达A时，A发送“知道B也不玩了”的ACK后，从FIN_WAIT_2状态结束，按说A可以直接跑路，但是最后这个ACK万一B收不到呢？则B会重新发送一个“B不玩了”，这个时候A已经跑了就无法给B发送ACK，所以会进入TIME-WAIT(等待2MSL)。

如果B超过了2MSL的时候，依然没有收到它发的FIN的ACK，按照TCP的原理，B会重发FIN，但是这个时候A已经等待了2MSL，之后的都不认了，会直接发送RST，B就知道A跑路了。

### TCP状态机

![示意图](/img/network-5.jpg)

在这个图中，加黑加粗的部分，是上面说到的主要流程，其中阿拉伯数字的序号，是 连接过程中的顺序，而大写中文数字的序号，是连接断开过程中的顺序。加粗的实线是客户端A的状态变迁，加粗的虚线是服务端B的状态变迁。

### 如何实现一个靠谱的协议

为了保证顺序性，每个包都有一个ID。在建立连接的时候，会商定起始的ID是什么，然后按照ID一个个发送。为了保证不丢包，对于发送的包都要进行应答，但是这个应答也不是一个个来的，而是会应答某个之前的ID，表示都收到了，这种模式成为累计确认或者累计应答(**cumulative acknowledgment**)。

为了记录所有发送的包和接收的包，TCP也需要发送端和接收端分别都有缓存来保持这些记录。发送端的缓存里是按照包的ID一个个排列，根据处理的情况分成四个部分。

> 第一部分：发送了并且已经确认的。

> 第二部分：发送了并且尚未确认的。

> 第三部分：没有发送，但是已经等待发送的。

> 第四部分：没有发生，并且暂时还不会发送的。

区分第三部分和第四部分是为了做到“流量控制，把握分寸”。

在TCP里，接收端会给发送端报一个窗口的大小，叫Advertised window。这个窗口的大小应该等于上面第二部分加第三部分，就是已经交代了没有做完的加上马上要交代的。超过这个窗口的，接收端做不过来，就不能发送了。

于是发送端需要保持下面的数据结构。

![示意图](/img/network-6.jpg)

对于接收端来讲，它的缓存里记录的内容要简单一些。

第一部分：接收并且确认过的。

第二部分：还没接收，但是马上就能接收的。

第三部分：还没接收，也没法接收的。

对应的数据结构就像这样。

![示意图](/img/network-7.jpg)



### 小结

* TCP包头很复杂，但是主要关注五个问题，顺序问题，丢包问题，连接维护，流量控制，拥塞控制
* 连接的建立是经过三次握手，断开的时候四次挥手。
* 顺序问题，丢包问题，流量控制都是通过滑动窗口来解决的。
* 拥塞控制是通过拥塞窗口来解决的。

## HTTP协议

TCP UDP属于传输层，最常用的HTTP是应用层的协议

### HTTP请求的准备

HTTP是基于TCP协议的，需要先建立TCP链接。目前使用的HTTP协议大部分都是1.1。在1.1的协议里面，默认是开启了Keep-Alive的，这样建立的TCP连接，就可以在多次请求中服用。（TCP的三次握手和四次挥手，如果好不容易建立了连接，然后做了一点事就结束了，有点浪费人力和物力）

### HTTP请求的构建

建立了连接后，浏览器就要发送HTTP的请求。

请求的格式就像这样

![示意图](/img/network-8.jpg)

HTTP的报文大概分为三大部分。（请求行、首部、正文实体）

#### 第一部分：请求行

请求行主要包含URL，版本，方法
例如http://www.163.com 是URL，版本是HTTP 1.1 ，方法是GET，其他主要方法还有POST,PUT,DELETE

#### 第二部分：首部字段

请求行下面就是首部字段。首部是 key value,通过冒号分隔。这里面往往保存一些非常重要的字段。

例如，**Accept-Charset** 表示**客户端可以接受的字符集**

例如，**Content-Type**是指**正文的格式**。

这里需要重点说一下的就是**缓存**。

一般在高并发场景下的系统，在真正的业务逻辑之前，都需要有个接入层，将这些静态资源的请求拦在最外面。

例如如下架构

![示意图](/img/network-9.jpg)

对于静态资源，有Vanish缓存层。当缓存过期的时候，才会访问真正的Tomcat应用集群。

在HTTP头里面，**Cache-control**是用来**控制缓存**的，当客户端发送的请求中包含max-age指令时，如果判定缓存层中，资源的缓存时间数值比指定时间的数值小，那么客户端可以接受缓存的资源；当指定的max-age=0，那么缓存层通常需要将请求转发给应用集群。

另外，If-Modified-Since也是一个关于缓存的。也就是说如果服务器的资源在某个时间之后更新了，那么客户端就应该下载最新的资源；如果没有更新，服务端就会返回“304 Not Modified”的响应，那客户端就不用下载了，节省带宽。

#### HTTP 请求的发送

HTTP协议是基于TCP协议的，所以它使用面向连接的方式来发送请求，通过stream二进制流的方式传给对方。当然，到了TCP层，它会把二进制流变成一个的报文段发送给服务器。

TCP层发送每一个报文的时候，都需要加上自己的地址和它想要去的地方(源地址和目标地址)，将这两个信息放到IP头里面，交给IP层进行传输。

IP层需要查看目标地址和自己是否在同一个局域网。如果是，就发送ARP协议来请求这个目标地址对应的MAC地址，然后将MAC(源和目标)放入MAC头，发送出去即可；如果不在一个局域网，就需要发送到网关，还要发送ARP协议，来获取网关的MAC地址，然后将源MAC和网关MAC放入MAC头，发送出去。

网关收到包发现MAC符合，取出IP地址，根据路由协议找到下一跳的路由器，获取下一跳路由器的MAC地址，将包发给下一跳的路由器。

这样路由器一跳一跳终于到达目标的局域网。这个时候，最后一跳的路由器能够发现，目标地址就在自己的某一个出口的局域网上。于是在这个局域网上发送ARP，获取这个目标地址的MAC地址，将包发出去。

目标的机器发现MAC地址符合，就将包收起来；发现IP地址符合，根据IP头中协议项，知道自己上一层是TCP协议，于是解析TCP的头，里面有序列号，需要看一看这个序列包是不是我要的，如果是就放入缓存中然后返回一个ACK，如果不是就丢弃。

TCP头里面还有端口号，HTTP的服务器正在监听这个端口号。于是目标机器自然知道是HTTP服务器这个进程想要这个包，于是就将包发给HTTP服务器。HTTP服务器的进程看到，原来这个请求是要访问一个网页，于是就把这个网页发给客户端。

#### HTTP返回的构建

HTTP的返回报文也是有一定格式的。这也是基于HTTP 1.1的。

