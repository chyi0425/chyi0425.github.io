---
title: network-overview
date: 2019-01-28 11:16:39
tags: [udp,tcp,network]
toc: true
---

## UDP协议

### UDP TCP区别

1. TCP提供可靠交付。通过TCP链接传输的数据，无差错，不丢失，不重复，并且按序到达。而UDP继承了IP包的特性，不保证不丢失，不保证按顺序到达。
2. TCP是面向字节流的。发送的时候发的是一个流，没头没尾。而UDP继承了IP包的特性，基于数据报的，一个一个地发，一个一个地收。
3. TCP是可以有拥塞控制的。UDP就不会，应用让我发，我就发，管他洪水滔天。

因此：**TCP其实是一个有状态服务**,而**UDP是无状态服务**

### UDP包头是什么样的

![示意图](/img/network-1.jpg)

### UDP的三大特点

1. 沟通简单，不需要一肚子花花肠子（大量的数据结构、处理逻辑、包头字段）提是它相信网络世界是美好的，秉承性善论，相信网络通路默认就是很容易送达的，不容易被丢弃的。
2. 轻信他人它不会建立连接，虽然有端口号，但是监听在这个地方，谁都可以传给他数据，他也可以传给任何人数据，甚至可以同时传给多个人数据。
3. 愣头青，做事不懂权变不知道什么时候该坚持，什么时候该退让。它不会根据网络的情况进行发包的拥塞控制，无论网络丢包丢成啥样了，它该怎么发还怎么发。

### UDP的三大使用场景

1. 需要资源少，在网络情况比较好的内网，或者对于丢包不敏感的应用。
2. 不需要一对一沟通，建立连接，而是可以广播的应用。
3. 需要处理速度快，时延低，可以容忍少数丢包，但是要求即便网络拥塞，也毫不退缩，一往无前的时候。

## TCP协议

### TCP的状态

* SYN表示建立连接
* FIN表示关闭连接
* ACK表示响应
* PSH表示有DATA数据传输
* RST表示连接重置 

### TCP包头格式

![示意图](/img/network-2.jpg)

通过对TCP头的解析，我们知道要掌握TCP协议，重点应该关注以下几个问题：

* 顺序问题，稳重不乱；
* 丢包问题，承诺靠谱
* 连接维护，有始有终；
* 流量控制，把握分寸；
* 拥塞控制，知进知退。

### TCP的三次握手

我们也常称为“请求->应答->应答之应答”的三个回合。

在连接建立的过程中，双方的状态变化时序图就像这样。

![示意图](/img/network-3.jpg)

一开始，客户端和服务的都处于CLOSE状态。先是服务端主动监听某个端口，处于LISTEN状态。然后客户端主动发起连接SYN，之后处于SYN-SENT状态。服务端收到发起的连接，返回SYN，并且ACK客户端的SYN，之后处于SYN-RCVD状态。客户端收到服务端发送的SYN和ACK之后，发送ACK的ACK，之后处于ESTABLISHED状态，因为它一发一收成功了。服务端收到ACK的ACK之后，处于ESTABLISHED状态，因为它也一发一收了。

### TCP四次挥手

说完连接，接下来说一说“拜拜”，好说好散。这常被称为四次挥手。

我们来看断开连接的时候的状态时序图

![示意图](/img/network-4.jpg)

当A说“不玩了”，就进入FIN_WAIT_1的状态，B收到“A不玩了”的消息后，发送知道了，就进入CLOSE_WAIT的状态。

A收到“B说知道了”，就进入FIN_WAIT_2的状态，如果这个时候B直接跑路，则A将永远在这个状态。TCP协议里面并没有对这个状态的处理，但是LINUX有，可以调整fin_fin_timeout这个参数，设置一个超时时间。

如果B没有跑路，发送了“B也不玩了”的请求到达A时，A发送“知道B也不玩了”的ACK后，从FIN_WAIT_2状态结束，按说A可以直接跑路，但是最后这个ACK万一B收不到呢？则B会重新发送一个“B不玩了”，这个时候A已经跑了就无法给B发送ACK，所以会进入TIME-WAIT(等待2MSL)。

如果B超过了2MSL的时候，依然没有收到它发的FIN的ACK，按照TCP的原理，B会重发FIN，但是这个时候A已经等待了2MSL，之后的都不认了，会直接发送RST，B就知道A跑路了。

### TCP状态机

![示意图](/img/network-5.jpg)
