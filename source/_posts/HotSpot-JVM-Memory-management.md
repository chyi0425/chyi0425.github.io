---
title: HotSpot JVM Memory management
date: 2018-07-24 14:34:29
tags: [Java,JVM] #文章标签，多于一项时用这种格式
toc: true
---
[文章出处](https://javadoop.com/post/jvm-memory-management)
### 垃圾收集概念

GC需要做3件事情：
* 分配内存，为每个新建的对象分配空间
* 确保还在使用的对象的内存一直还在，不能把有用的空间当垃圾回收了
* 释放不再使用的对象所占用的空间

我们把还被**GC Roots** 引用的对象称为活的，把不再被引用的对象认为是死的，也就是我们说的垃圾，GC 的工作就是找到死的对象，回收它们占用的空间。

在这里，我们总结一下 GC Roots 有哪些：

* 所有Java线程当前活跃的栈帧里指向GC堆里的对象的引用；换句话说，当前所有正在被调用的方法的引用类型的参数/局部变量/临时值。
* VM的一些静态数据结构里指向GC堆里的对象的引用，例如说HotSpot VM里的Universe里有很多这样的引用。
* JNI handles，包括global handles和local handles

https://www.zhihu.com/question/53613423/answer/135743258

我们把 GC 管理的内存称为 **堆（heap）**，垃圾收集启动的时机取决于各个垃圾收集器，通常，垃圾收集发生于整个堆或堆的部分已经被使用光了，或者使用的空间达到了某个百分比阈值。这些后面都会具体说，这里的每一句话都是对应了某些场景的。

对于内存分配请求，实现的难点在于在堆中找到一块没有被使用的确定大小的内存空间。所以，对于大部分垃圾回收算法来说**避免内存碎片化**是非常重要的，它将使得空间分配更加高效。

#### 垃圾收集器的理想特征

1. 安全和全面：活的对象一定不能被清理掉，死的对象一定不能在几个回收周期结束后还在内存中。
2. 高效：不能将我们的应用程序挂起太长时间。我们需要在时间、空间、频次上作出权衡。比如，如果堆内存很小，每次垃圾收集就会很快，但是频次会增加。如果堆内存很大，很久才会被填满，但是每一次回收需要的时间很长。
3. 尽量少的内存碎片：每次将垃圾对象释放以后，这些空间可能分布在各个地方，最糟糕的情况就是，内存中到处都是碎片，在给一个大对象分配空间的时候没有内存可用，实际上内存是够的。消除碎片的方式就是**压缩**。
4. 可扩展性：在多核多线程应用中，内存分配和垃圾回收都不应该成为可扩展性的瓶颈。(Scalability is also important. Allocation should not become a scalability bottleneck for multithreaded applications on multiprocessor systems, and collection should also not be such a bottleneck.)

#### 设计上的权衡

往下看之前，我们需要先分清楚这里的两个概念：并发和并行

* 并行：多个垃圾回收线程同时工作，而不是只有一个垃圾回收线程在工作。
* 并发：垃圾回收线程和应用程序线程同时工作，应用程序不需要挂起。

在设计或选择垃圾回收算法的时候，我们需要做出以下几个权衡

* 串行 vs 并行

串行收集的情况，即使是多核CPU，也只有一个核心参与收集。